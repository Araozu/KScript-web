// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function run(parser, entrada, inicio) {
  return Curry._2(parser[0], entrada, inicio);
}

function bindP(f, p) {
  var innerFn = function (entrada, inicio) {
    var result1 = run(p, entrada, inicio);
    if (result1.tag) {
      return /* Error */Block.__(1, [result1[0]]);
    } else {
      var ex = result1[0];
      var resultado = ex.res;
      var posSiguiente = ex.posFinal;
      var p2 = Curry._1(f, resultado);
      return run(p2, entrada, posSiguiente);
    }
  };
  return /* Parser */[innerFn];
}

function $great$great$eq(p, f) {
  return bindP(f, p);
}

function returnP(x) {
  var innerFn = function (param, inicio) {
    return /* Exito */Block.__(0, [{
                res: x,
                posInicio: inicio,
                posFinal: inicio,
                tipo: /* Nada */11
              }]);
  };
  return /* Parser */[innerFn];
}

function mapP(f, p) {
  var inner = function (entrada, inicio) {
    var res = run(p, entrada, inicio);
    if (res.tag) {
      return /* Error */Block.__(1, [res[0]]);
    } else {
      var ex = res[0];
      return /* Exito */Block.__(0, [{
                  res: Curry._1(f, ex.res),
                  posInicio: ex.posInicio,
                  posFinal: ex.posFinal,
                  tipo: ex.tipo
                }]);
    }
  };
  return /* Parser */[inner];
}

function applyP(fP, xP) {
  return bindP((function (f) {
                return bindP((function (x) {
                              return returnP(Curry._1(f, x));
                            }), xP);
              }), fP);
}

function lift2(f, xP, yP) {
  return applyP(applyP(returnP(f), xP), yP);
}

function parseCaracter(caracter) {
  var inner = function (entrada, inicio) {
    if (entrada === "" || inicio >= entrada.length) {
      return /* Error */Block.__(1, ["Entrada terminada"]);
    } else {
      var c = $$String.sub(entrada, inicio, 1);
      if (c === caracter) {
        return /* Exito */Block.__(0, [{
                    res: c,
                    posInicio: inicio,
                    posFinal: inicio + 1 | 0,
                    tipo: /* Nada */11
                  }]);
      } else {
        return /* Error */Block.__(1, ["Se esperaba \'" + (String(caracter) + ("\', pero se obtuvo \'" + (String(c) + "\'.")))]);
      }
    }
  };
  return /* Parser */[inner];
}

function parseLuego(p1, p2) {
  var inner = function (entrada, inicio) {
    var res1 = run(p1, entrada, inicio);
    if (res1.tag) {
      return /* Error */Block.__(1, [res1[0]]);
    } else {
      var ex1 = res1[0];
      var res2 = run(p2, entrada, ex1.posFinal);
      if (res2.tag) {
        return /* Error */Block.__(1, [res2[0]]);
      } else {
        var ex2 = res2[0];
        return /* Exito */Block.__(0, [{
                    res: /* tuple */[
                      ex1.res,
                      ex2.res
                    ],
                    posInicio: inicio,
                    posFinal: ex2.posFinal,
                    tipo: /* Nada */11
                  }]);
      }
    }
  };
  return /* Parser */[inner];
}

function parseOtro(p1, p2) {
  var innerFn = function (entrada, inicio) {
    var result1 = run(p1, entrada, inicio);
    if (result1.tag) {
      return run(p2, entrada, inicio);
    } else {
      return result1;
    }
  };
  return /* Parser */[innerFn];
}

function escoger(listOfParsers) {
  var primer = List.hd(listOfParsers);
  var resto = List.tl(listOfParsers);
  return List.fold_left(parseOtro, primer, resto);
}

function cualquier(listOfChars) {
  return escoger(List.map(parseCaracter, listOfChars));
}

function sequence(parserList) {
  var cons = function (head, tail) {
    return /* :: */[
            head,
            tail
          ];
  };
  if (parserList) {
    return lift2(cons, parserList[0], sequence(parserList[1]));
  } else {
    var innerFn = function (param, inicio) {
      return /* Exito */Block.__(0, [{
                  res: /* [] */0,
                  posInicio: inicio,
                  posFinal: inicio,
                  tipo: /* Nada */11
                }]);
    };
    return /* Parser */[innerFn];
  }
}

function parseVariosHelper(parser, entrada, inicio) {
  var resultado = run(parser, entrada, inicio);
  if (resultado.tag) {
    return /* tuple */[
            /* [] */0,
            inicio
          ];
  } else {
    var ex = resultado[0];
    var resultado$1 = ex.res;
    var posSig = ex.posFinal;
    var match = parseVariosHelper(parser, entrada, posSig);
    return /* tuple */[
            /* :: */[
              resultado$1,
              match[0]
            ],
            match[1]
          ];
  }
}

function parseVarios(parser) {
  var inner = function (entrada, inicio) {
    var match = parseVariosHelper(parser, entrada, inicio);
    return /* Exito */Block.__(0, [{
                res: match[0],
                posInicio: inicio,
                posFinal: match[1],
                tipo: /* Nada */11
              }]);
  };
  return /* Parser */[inner];
}

function parseVarios1(parser) {
  var inner = function (entrada, inicio) {
    var match = parseVariosHelper(parser, entrada, inicio);
    var datos = match[0];
    if (datos) {
      return /* Exito */Block.__(0, [{
                  res: datos,
                  posInicio: inicio,
                  posFinal: match[1],
                  tipo: /* Nada */11
                }]);
    } else {
      return /* Error */Block.__(1, [""]);
    }
  };
  return /* Parser */[inner];
}

function parseSegundoOpcional(p1, p2) {
  var inner = function (entrada, inicio) {
    var res1 = run(p1, entrada, inicio);
    if (res1.tag) {
      return /* Error */Block.__(1, [res1[0]]);
    } else {
      var ex1 = res1[0];
      var res2 = run(p2, entrada, ex1.posFinal);
      if (res2.tag) {
        return /* Exito */Block.__(0, [{
                    res: /* tuple */[
                      ex1.res,
                      undefined
                    ],
                    posInicio: inicio,
                    posFinal: ex1.posFinal,
                    tipo: /* Nada */11
                  }]);
      } else {
        var ex2 = res2[0];
        return /* Exito */Block.__(0, [{
                    res: /* tuple */[
                      ex1.res,
                      Caml_option.some(ex2.res)
                    ],
                    posInicio: inicio,
                    posFinal: ex2.posFinal,
                    tipo: /* Nada */11
                  }]);
      }
    }
  };
  return /* Parser */[inner];
}

function parseCualquierMenos(caracter) {
  var inner = function (entrada, inicio) {
    if (entrada === "" || inicio >= entrada.length) {
      return /* Error */Block.__(1, ["Entrada terminada"]);
    } else {
      var c = $$String.sub(entrada, inicio, 1);
      if (caracter === c) {
        return /* Error */Block.__(1, ["Se encontr\xc3\xb3 el caracter a no parsear."]);
      } else {
        return /* Exito */Block.__(0, [{
                    res: c,
                    posInicio: inicio,
                    posFinal: inicio + 1 | 0,
                    tipo: /* Nada */11
                  }]);
      }
    }
  };
  return /* Parser */[inner];
}

function crearSome(x) {
  return Caml_option.some(x);
}

function pOpc(p) {
  var some = mapP(crearSome, p);
  var innerFn = function (param, inicio) {
    return /* Exito */Block.__(0, [{
                res: undefined,
                posInicio: inicio,
                posFinal: inicio,
                tipo: /* Nada */11
              }]);
  };
  var none = /* Parser */[innerFn];
  return parseOtro(some, none);
}

function $pipe$great$great(p1, p2) {
  return mapP((function (param) {
                return param[0];
              }), parseLuego(p1, p2));
}

function $great$great$pipe(p1, p2) {
  return mapP((function (param) {
                return param[1];
              }), parseLuego(p1, p2));
}

function between(p1, p2, p3) {
  return $pipe$great$great($great$great$pipe(p1, p2), p3);
}

function parseVariasOpciones(parsers) {
  var inner = function (entrada, pos) {
    var _parsers = parsers;
    while(true) {
      var parsers$1 = _parsers;
      if (parsers$1) {
        var resultado = run(parsers$1[0], entrada, pos);
        if (resultado.tag) {
          _parsers = parsers$1[1];
          continue ;
        } else {
          var ex = resultado[0];
          return /* Exito */Block.__(0, [{
                      res: ex.res,
                      posInicio: ex.posInicio,
                      posFinal: ex.posFinal,
                      tipo: ex.tipo
                    }]);
        }
      } else {
        return /* Error */Block.__(1, ["Ningun parser se adapta a la entrada. En la posic√≠on " + (String(pos) + ".")]);
      }
    };
  };
  return /* Parser */[inner];
}

function mapTipo(parser, nuevoTipo) {
  var inner = function (entrada, inicio) {
    var res = run(parser, entrada, inicio);
    if (res.tag) {
      return /* Error */Block.__(1, [res[0]]);
    } else {
      var ex = res[0];
      return /* Exito */Block.__(0, [{
                  res: ex.res,
                  posInicio: ex.posInicio,
                  posFinal: ex.posFinal,
                  tipo: nuevoTipo
                }]);
    }
  };
  return /* Parser */[inner];
}

var $less$bang$great = mapP;

var $less$star$great = applyP;

var $pipe$great$great$pipe = parseLuego;

var $less$pipe$great = parseOtro;

var $less$question$great = parseSegundoOpcional;

exports.run = run;
exports.bindP = bindP;
exports.$great$great$eq = $great$great$eq;
exports.returnP = returnP;
exports.mapP = mapP;
exports.$less$bang$great = $less$bang$great;
exports.applyP = applyP;
exports.$less$star$great = $less$star$great;
exports.lift2 = lift2;
exports.parseCaracter = parseCaracter;
exports.parseLuego = parseLuego;
exports.$pipe$great$great$pipe = $pipe$great$great$pipe;
exports.parseOtro = parseOtro;
exports.$less$pipe$great = $less$pipe$great;
exports.escoger = escoger;
exports.cualquier = cualquier;
exports.sequence = sequence;
exports.parseVariosHelper = parseVariosHelper;
exports.parseVarios = parseVarios;
exports.parseVarios1 = parseVarios1;
exports.parseSegundoOpcional = parseSegundoOpcional;
exports.$less$question$great = $less$question$great;
exports.parseCualquierMenos = parseCualquierMenos;
exports.crearSome = crearSome;
exports.pOpc = pOpc;
exports.$pipe$great$great = $pipe$great$great;
exports.$great$great$pipe = $great$great$pipe;
exports.between = between;
exports.parseVariasOpciones = parseVariasOpciones;
exports.mapTipo = mapTipo;
/* No side effect */
