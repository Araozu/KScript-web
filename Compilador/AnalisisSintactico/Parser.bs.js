// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Expect$KanComp = require("./Expect.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function obtSigIndentacion(lexer, msgError, fnErrorLexer, fnEOF) {
  var hayNuevaLinea = false;
  try {
    while(true) {
      Expect$KanComp._TNuevaLinea(Curry._1(lexer.lookAhead, /* () */0), undefined, "");
      hayNuevaLinea = true;
      Curry._1(lexer.sigToken, /* () */0);
    };
    return /* tuple */[
            1,
            true
          ];
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Expect$KanComp.ErrorComun) {
      var match = Expect$KanComp._Any(Curry._1(lexer.lookAhead, /* () */0), msgError, fnErrorLexer, fnEOF);
      return /* tuple */[
              match[1],
              hayNuevaLinea
            ];
    } else {
      throw exn;
    }
  }
}

function parseTokens(lexer) {
  var sigExprDeclaracion = function (nivel) {
    try {
      var esMut = false;
      var token2 = Curry._1(lexer.sigToken, /* () */0);
      var preTokenId = token2;
      try {
        Expect$KanComp._PC_MUT(token2, undefined, "");
        esMut = true;
        preTokenId = Curry._1(lexer.sigToken, /* () */0);
      }
      catch (exn){
        
      }
      var infoTokenId = Expect$KanComp._TIdentificador(preTokenId, undefined, "Se esperaba un identificador");
      Expect$KanComp._TOperador(Curry._1(lexer.sigToken, /* () */0), "=", "Se esperaba el operador de asignaci\xc3\xb3n '=' luego del indentificador.");
      var match = obtSigIndentacion(lexer, "Se esperaba una expresion luego del signo '='.", undefined, undefined);
      var hayNuevaLinea = match[1];
      var nuevoNivel = match[0];
      if (hayNuevaLinea && nuevoNivel <= nivel) {
        throw [
              Expect$KanComp.ErrorComun,
              "La expresi\xc3\xb3n actual est\xc3\xa1 incompleta. Se esperaba una expresi\xc3\xb3n indentada."
            ];
      }
      var match$1 = sigExpresion(nuevoNivel, hayNuevaLinea);
      if (typeof match$1 === "number") {
        return /* PError */Block.__(1, ["Se esperaba una expresi\xc3\xb3n luego de la asignacion."]);
      } else if (match$1.tag) {
        return /* PError */Block.__(1, ["Se esperaba una expresión luego de la asignación:"]);
      } else {
        return /* PExito */Block.__(0, [/* EDeclaracion */Block.__(8, [{
                        mut: esMut,
                        id: {
                          signatura: /* Indefinida */0,
                          valor: infoTokenId
                        },
                        valor: match$1[0]
                      }])]);
      }
    }
    catch (raw_exn){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn$1[0] === Expect$KanComp.ErrorComun) {
        return /* PError */Block.__(1, [exn$1[1]]);
      } else {
        throw exn$1;
      }
    }
  };
  var sigExprFuncion = function (_funExpr, _paramExpr, nivel) {
    while(true) {
      var paramExpr = _paramExpr;
      var funExpr = _funExpr;
      var exprFunAct = /* EFuncion */Block.__(7, [{
            signatura: /* Indefinida */0,
            fn: funExpr,
            param: paramExpr
          }]);
      var match = Curry._1(lexer.sigToken, /* () */0);
      if (typeof match === "number") {
        return /* PExito */Block.__(0, [exprFunAct]);
      } else if (match.tag) {
        return /* PError */Block.__(1, [match[0]]);
      } else {
        var token = match[0];
        switch (token.tag | 0) {
          case /* TIdentificador */1 :
              var expr2 = /* EIdentificador */Block.__(0, [{
                    signatura: /* Indefinida */0,
                    valor: token[0]
                  }]);
              _paramExpr = expr2;
              _funExpr = exprFunAct;
              continue ;
          case /* TNumero */4 :
              var expr2$1 = /* ENumero */Block.__(2, [token[0]]);
              _paramExpr = expr2$1;
              _funExpr = exprFunAct;
              continue ;
          case /* TTexto */5 :
              var expr2$2 = /* ETexto */Block.__(3, [token[0]]);
              _paramExpr = expr2$2;
              _funExpr = exprFunAct;
              continue ;
          case /* TBool */6 :
              var expr2$3 = /* EBool */Block.__(4, [token[0]]);
              _paramExpr = expr2$3;
              _funExpr = exprFunAct;
              continue ;
          default:
            return /* PExito */Block.__(0, [exprFunAct]);
        }
      }
    };
  };
  var sigExpresion = function (nivel, aceptarExprMismoNivel) {
    var resultado = Curry._1(lexer.sigToken, /* () */0);
    var sigExprActual;
    if (typeof resultado === "number") {
      sigExprActual = /* PEOF */0;
    } else if (resultado.tag) {
      sigExprActual = /* PError */Block.__(1, [resultado[0]]);
    } else {
      var token = resultado[0];
      switch (token.tag | 0) {
        case /* TIdentificador */1 :
            sigExprActual = sigExprIdentificador(token[0], nivel);
            break;
        case /* TGenerico */2 :
            sigExprActual = /* PError */Block.__(1, ["Los genericos aun no estan soportados."]);
            break;
        case /* TNuevaLinea */0 :
        case /* TComentario */3 :
            sigExprActual = sigExpresion(nivel, aceptarExprMismoNivel);
            break;
        case /* TNumero */4 :
            sigExprActual = /* PExito */Block.__(0, [/* ENumero */Block.__(2, [token[0]])]);
            break;
        case /* TTexto */5 :
            sigExprActual = /* PExito */Block.__(0, [/* ETexto */Block.__(3, [token[0]])]);
            break;
        case /* TBool */6 :
            sigExprActual = /* PExito */Block.__(0, [/* EBool */Block.__(4, [token[0]])]);
            break;
        case /* TOperador */7 :
            sigExprActual = /* PError */Block.__(1, ["No se puede usar un operador como expresion. Si esa es tu intenci\xc3\xb3n, rodea el operador en par\xc3\xa9ntesis, por ejemplo: (+)"]);
            break;
        case /* TParenAb */8 :
            var infoParen = token[0];
            var sigToken = sigExpresion(nivel, false);
            if (typeof sigToken === "number") {
              var posInicio = infoParen.inicio;
              sigExprActual = /* PError */Block.__(1, ["El parentesis abierto en " + (String(posInicio) + " no está cerrado.")]);
            } else if (sigToken.tag) {
              sigExprActual = sigToken;
            } else {
              var ultimoToken = Curry._1(lexer.sigToken, /* () */0);
              sigExprActual = typeof ultimoToken === "number" ? /* PError */Block.__(1, ["El parentesis abierto en " + (String(infoParen) + ".inicio contiene una expresion, pero no está cerrado.")]) : (
                  ultimoToken.tag ? /* PError */Block.__(1, ["El parentesis abierto en " + (String(infoParen) + (".inicio no está cerrado debido a un error léxico: " + (String(ultimoToken[0]) + "")))]) : (
                      ultimoToken[0].tag === /* TParenCer */9 ? /* PExito */Block.__(0, [sigToken[0]]) : /* PError */Block.__(1, ["Se esperaba un cierre de parentesis."])
                    )
                );
            }
            break;
        case /* TParenCer */9 :
            sigExprActual = /* PError */Block.__(1, ["No se esperaba un parentesis aqu\xc3\xad."]);
            break;
        case /* TAgrupAb */10 :
        case /* TAgrupCer */11 :
            sigExprActual = /* PError */Block.__(1, ["Otros signos de agrupacion aun no estan soportados."]);
            break;
        case /* PC_SEA */12 :
            sigExprActual = sigExprDeclaracion(nivel);
            break;
        case /* PC_MUT */13 :
            sigExprActual = /* PError */Block.__(1, ["No se esperaba la palabra clave 'sea' aqu\xc3\xad."]);
            break;
        
      }
    }
    if (typeof sigExprActual === "number" || sigExprActual.tag) {
      return sigExprActual;
    } else {
      var exprAct = sigExprActual[0];
      try {
        var match = obtSigIndentacion(lexer, "", (function (x) {
                return [
                        Expect$KanComp.OpInvalida,
                        x
                      ];
              }), undefined);
        if (aceptarExprMismoNivel && match[0] === nivel) {
          var sigExprTop = sigExpresion(nivel, aceptarExprMismoNivel);
          if (typeof sigExprTop === "number") {
            return sigExprActual;
          } else if (sigExprTop.tag) {
            return /* PError */Block.__(1, [sigExprTop[0]]);
          } else {
            var expr = sigExprTop[0];
            var tmp;
            tmp = expr.tag === /* EBloque */9 ? /* EBloque */Block.__(9, [/* :: */[
                    exprAct,
                    expr[0]
                  ]]) : /* EBloque */Block.__(9, [/* :: */[
                    exprAct,
                    /* :: */[
                      expr,
                      /* [] */0
                    ]
                  ]]);
            return /* PExito */Block.__(0, [tmp]);
          }
        } else {
          return sigExprActual;
        }
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === Expect$KanComp.OpInvalida) {
          return /* PError */Block.__(1, [exn[1]]);
        } else {
          return sigExprActual;
        }
      }
    }
  };
  var sigExprIdentificador = function (infoId, nivel) {
    var primeraExprId = /* EIdentificador */Block.__(0, [{
          signatura: /* Indefinida */0,
          valor: infoId
        }]);
    var match = Curry._1(lexer.sigToken, /* () */0);
    if (typeof match === "number") {
      return /* PExito */Block.__(0, [primeraExprId]);
    } else if (match.tag) {
      return /* PError */Block.__(1, [match[0]]);
    } else {
      var token = match[0];
      switch (token.tag | 0) {
        case /* TIdentificador */1 :
            var expr2 = /* EIdentificador */Block.__(0, [{
                  signatura: /* Indefinida */0,
                  valor: token[0]
                }]);
            return sigExprFuncion(primeraExprId, expr2, nivel);
        case /* TNumero */4 :
            var expr2$1 = /* ENumero */Block.__(2, [token[0]]);
            return sigExprFuncion(primeraExprId, expr2$1, nivel);
        case /* TTexto */5 :
            var expr2$2 = /* ETexto */Block.__(3, [token[0]]);
            return sigExprFuncion(primeraExprId, expr2$2, nivel);
        case /* TBool */6 :
            var expr2$3 = /* EBool */Block.__(4, [token[0]]);
            return sigExprFuncion(primeraExprId, expr2$3, nivel);
        default:
          return /* PExito */Block.__(0, [primeraExprId]);
      }
    }
  };
  var exprRe = sigExpresion(0, true);
  if (typeof exprRe === "number") {
    return /* ErrorParser */Block.__(1, ["EOF sin tratar en el parser."]);
  } else if (exprRe.tag) {
    return /* ErrorParser */Block.__(1, [exprRe[0]]);
  } else {
    return /* ExitoParser */Block.__(0, [exprRe[0]]);
  }
}

exports.obtSigIndentacion = obtSigIndentacion;
exports.parseTokens = parseTokens;
/* No side effect */
