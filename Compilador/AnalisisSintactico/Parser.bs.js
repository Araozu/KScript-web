// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Expect$KanComp = require("./Expect.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function obtInfoFunAppl(esCurry) {
  return {
          valor: esCurry ? "Ñ" : "ñ",
          inicio: -1,
          final: -1,
          numLinea: -1,
          posInicioLinea: -1
        };
}

function obtSigIndentacion(lexer, msgError, fnErrorLexer, fnEOF) {
  var hayNuevaLinea = false;
  try {
    while(true) {
      Expect$KanComp._TNuevaLinea(Curry._1(lexer.lookAhead, /* () */0), undefined, "");
      hayNuevaLinea = true;
      Curry._1(lexer.sigToken, /* () */0);
    };
    return /* tuple */[
            1,
            true
          ];
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Expect$KanComp.ErrorComun) {
      var match = Expect$KanComp._Any(Curry._1(lexer.lookAhead, /* () */0), msgError, fnErrorLexer, fnEOF);
      return /* tuple */[
              match[1],
              hayNuevaLinea
            ];
    } else {
      throw exn;
    }
  }
}

function obtInfoOp(operador) {
  switch (operador) {
    case "&&" :
        return /* tuple */[
                6,
                /* Izq */0
              ];
    case "," :
        return /* tuple */[
                1,
                /* Izq */0
              ];
    case "+" :
    case "-" :
        return /* tuple */[
                10,
                /* Izq */0
              ];
    case "." :
        return /* tuple */[
                15,
                /* Izq */0
              ];
    case "%" :
    case "*" :
    case "/" :
        return /* tuple */[
                11,
                /* Izq */0
              ];
    case "!=" :
    case "!==" :
    case "==" :
    case "===" :
        return /* tuple */[
                8,
                /* Izq */0
              ];
    case "<" :
    case "<=" :
    case ">" :
    case ">=" :
        return /* tuple */[
                9,
                /* Izq */0
              ];
    case "<<" :
    case ">>" :
        return /* tuple */[
                4,
                /* Izq */0
              ];
    case "??" :
        return /* tuple */[
                7,
                /* Izq */0
              ];
    case "^" :
        return /* tuple */[
                12,
                /* Der */1
              ];
    case "%=" :
    case "*=" :
    case "+=" :
    case "-=" :
    case "/=" :
    case "=" :
    case "^=" :
        return /* tuple */[
                2,
                /* Izq */0
              ];
    case "<|" :
    case "|>" :
        return /* tuple */[
                3,
                /* Izq */0
              ];
    case "||" :
        return /* tuple */[
                5,
                /* Izq */0
              ];
    default:
      if (operador === "Ñ" || operador === "ñ") {
        return /* tuple */[
                14,
                /* Izq */0
              ];
      } else {
        return /* tuple */[
                13,
                /* Izq */0
              ];
      }
  }
}

function parseTokens(lexer) {
  var generarTextoError = function (info) {
    var largo = info.final - info.posInicioLinea | 0;
    var substr = $$String.sub(lexer.entrada, info.posInicioLinea, largo);
    var espBlanco = $$String.make(info.inicio - info.posInicioLinea | 0, /* " " */32);
    var indicador = $$String.make(info.final - info.inicio | 0, /* "~" */126);
    var numLinea = info.numLinea;
    var strIndicadorNumLinea = " " + (String(numLinea) + " | ");
    var espacioBlancoIndicador = $$String.make(strIndicadorNumLinea.length, /* " " */32);
    var strIndicador = "" + (String(espBlanco) + ("" + (String(indicador) + "")));
    return "" + (String(strIndicadorNumLinea) + ("" + (String(substr) + ("\n" + (String(espacioBlancoIndicador) + ("" + (String(strIndicador) + "\n")))))));
  };
  var sigExprOperador = function (_exprIzq, _infoOp, nivel, _precedencia, _asociatividad) {
    while(true) {
      var infoOp = _infoOp;
      var exprIzq = _exprIzq;
      var valorOp = infoOp.valor;
      var match = obtInfoOp(valorOp);
      var match$1 = sigExpresion(nivel, false, match[0], match[1]);
      if (typeof match$1 === "number") {
        return /* PError */Block.__(1, ["Se esperaba una expresión a la derecha del operador " + (String(valorOp) + "")]);
      } else if (match$1.tag) {
        return /* PError */Block.__(1, ["Se esperaba una expresion a la derecha del operador " + (String(valorOp) + (" :\n" + (String(match$1[0]) + ".")))]);
      } else {
        var eOperadorRes = {
          signatura: /* Indefinida */0,
          valor: infoOp
        };
        var exprOpRes = /* EOperadorApl */Block.__(6, [{
              op: eOperadorRes,
              izq: exprIzq,
              der: match$1[0]
            }]);
        var match$2 = Curry._1(lexer.sigToken, /* () */0);
        if (typeof match$2 === "number") {
          return /* PExito */Block.__(0, [exprOpRes]);
        } else if (match$2.tag) {
          return /* PError */Block.__(1, [match$2[0]]);
        } else {
          var token = match$2[0];
          switch (token.tag | 0) {
            case /* TNuevaLinea */0 :
                console.log("El nivel de la expresion es " + (String(nivel) + ""));
                return /* PExito */Block.__(0, [exprOpRes]);
            case /* TGenerico */2 :
                var textoError = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["No se esperaba un genérico luego de la aplicación del operador.\n\n" + (String(textoError) + "")]);
            case /* TComentario */3 :
                return /* PExito */Block.__(0, [exprOpRes]);
            case /* TOperador */7 :
                var infoOp2 = token[0];
                var match$3 = obtInfoOp(infoOp2.valor);
                _asociatividad = match$3[1];
                _precedencia = match$3[0];
                _infoOp = infoOp2;
                _exprIzq = exprOpRes;
                continue ;
            case /* TParenAb */8 :
                var sigExpr = sigExprParen(token[0], nivel);
                if (typeof sigExpr === "number") {
                  return /* PError */Block.__(1, ["Hay un parentesis sin cerrar."]);
                } else if (sigExpr.tag) {
                  return /* PError */Block.__(1, [sigExpr[0]]);
                } else {
                  var infoOpFunApl_valor = "ñ";
                  var infoOpFunApl = {
                    valor: infoOpFunApl_valor,
                    inicio: -1,
                    final: -1,
                    numLinea: -1,
                    posInicioLinea: -1
                  };
                  return /* PExito */Block.__(0, [/* EOperadorApl */Block.__(6, [{
                                  op: {
                                    signatura: /* Indefinida */0,
                                    valor: infoOpFunApl
                                  },
                                  izq: exprOpRes,
                                  der: sigExpr[0]
                                }])]);
                }
            case /* TParenCer */9 :
                Curry._1(lexer.retroceder, /* () */0);
                return /* PExito */Block.__(0, [exprOpRes]);
            case /* TAgrupAb */10 :
                var textoError$1 = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["Este signo de agrupación aun no está soportado.\n\n" + (String(textoError$1) + "")]);
            case /* TAgrupCer */11 :
                var textoError$2 = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["Este signo de agrupación aun no está soportado.\n\n" + (String(textoError$2) + "")]);
            case /* PC_SEA */12 :
                var textoError$3 = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["No se esperaba la palabra clave \'sea\' luego de la aplicación del operador.\n\n" + (String(textoError$3) + "")]);
            case /* PC_MUT */13 :
                var textoError$4 = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["No se esperaba la palabra clave \'mut\' luego de la aplicación del operador.\n\n" + (String(textoError$4) + "")]);
            default:
              var infoOp2_valor = "ñ";
              var infoOp2$1 = {
                valor: infoOp2_valor,
                inicio: -1,
                final: -1,
                numLinea: -1,
                posInicioLinea: -1
              };
              var match$4 = obtInfoOp("ñ");
              Curry._1(lexer.retroceder, /* () */0);
              _asociatividad = match$4[1];
              _precedencia = match$4[0];
              _infoOp = infoOp2$1;
              _exprIzq = exprOpRes;
              continue ;
          }
        }
      }
    };
  };
  var sigExprParen = function (infoParen, nivel) {
    var sigToken = sigExpresion(nivel, false, 0, /* Izq */0);
    if (typeof sigToken === "number") {
      var textoErr = generarTextoError(infoParen);
      var numLinea = infoParen.numLinea;
      var numColumna = infoParen.inicio - infoParen.posInicioLinea | 0;
      return /* PError */Block.__(1, ["El parentesis abierto en " + (String(numLinea) + ("," + (String(numColumna) + (" no está cerrado.\n\n" + (String(textoErr) + "")))))]);
    } else if (sigToken.tag) {
      return sigToken;
    } else {
      var ultimoToken = Curry._1(lexer.sigToken, /* () */0);
      if (typeof ultimoToken === "number") {
        var textoErr$1 = generarTextoError(infoParen);
        var numLinea$1 = infoParen.numLinea;
        var numColumna$1 = infoParen.inicio - infoParen.posInicioLinea | 0;
        return /* PError */Block.__(1, ["El parentesis abierto en " + (String(numLinea$1) + ("," + (String(numColumna$1) + (" contiene una expresion, pero no está cerrado.\n\n" + (String(textoErr$1) + "")))))]);
      } else if (ultimoToken.tag) {
        var textoErr$2 = generarTextoError(infoParen);
        var numLinea$2 = infoParen.numLinea;
        var numColumna$2 = infoParen.inicio - infoParen.posInicioLinea | 0;
        return /* PError */Block.__(1, ["El parentesis abierto en " + (String(numLinea$2) + ("," + (String(numColumna$2) + (" no está cerrado.\n\n" + (String(textoErr$2) + ("\nDebido a un error léxico: " + (String(ultimoToken[0]) + "")))))))]);
      } else if (ultimoToken[0].tag === /* TParenCer */9) {
        return /* PExito */Block.__(0, [sigToken[0]]);
      } else {
        return /* PError */Block.__(1, ["Se esperaba un cierre de parentesis."]);
      }
    }
  };
  var sigExpresion = function (nivel, iniciarIndentacionEnToken, precedencia, asociatividad) {
    while(true) {
      var obtNuevoNivel = function (infoToken) {
        if (iniciarIndentacionEnToken) {
          return infoToken.inicio - infoToken.posInicioLinea | 0;
        } else {
          return nivel;
        }
      };
      var resultado = Curry._1(lexer.sigToken, /* () */0);
      if (typeof resultado === "number") {
        return /* PEOF */0;
      } else if (resultado.tag) {
        return /* PError */Block.__(1, [resultado[0]]);
      } else {
        var token = resultado[0];
        switch (token.tag | 0) {
          case /* TIdentificador */1 :
              var infoId = token[0];
              var infoId$1 = infoId;
              var nivel$1 = obtNuevoNivel(infoId);
              var precedencia$1 = precedencia;
              var primeraExprId = /* EIdentificador */Block.__(0, [{
                    signatura: /* Indefinida */0,
                    valor: infoId$1
                  }]);
              var match = Curry._1(lexer.sigToken, /* () */0);
              if (typeof match === "number") {
                return /* PExito */Block.__(0, [primeraExprId]);
              } else if (match.tag) {
                return /* PError */Block.__(1, [match[0]]);
              } else {
                var token$1 = match[0];
                switch (token$1.tag | 0) {
                  case /* TNuevaLinea */0 :
                      Curry._1(lexer.retroceder, /* () */0);
                      return /* PExito */Block.__(0, [primeraExprId]);
                  case /* TIdentificador */1 :
                  case /* TNumero */4 :
                  case /* TTexto */5 :
                  case /* TBool */6 :
                      break;
                  case /* TOperador */7 :
                      var infoOp = token$1[0];
                      var match$1 = obtInfoOp(infoOp.valor);
                      var asocOp = match$1[1];
                      var precOp = match$1[0];
                      if (precOp > precedencia$1 || precOp === precedencia$1 && asocOp === /* Der */1) {
                        return sigExprOperador(primeraExprId, infoOp, nivel$1, precOp, asocOp);
                      } else {
                        Curry._1(lexer.retroceder, /* () */0);
                        return /* PExito */Block.__(0, [primeraExprId]);
                      }
                  default:
                    Curry._1(lexer.retroceder, /* () */0);
                    return /* PExito */Block.__(0, [primeraExprId]);
                }
                Curry._1(lexer.retroceder, /* () */0);
                if (14 > precedencia$1) {
                  var infoOpFunApl_valor = "ñ";
                  var infoOpFunApl = {
                    valor: infoOpFunApl_valor,
                    inicio: -1,
                    final: -1,
                    numLinea: -1,
                    posInicioLinea: -1
                  };
                  return sigExprOperador(primeraExprId, infoOpFunApl, nivel$1, 14, /* Izq */0);
                } else if (14 === precedencia$1 && false) {
                  var infoOpFunApl_valor$1 = "ñ";
                  var infoOpFunApl$1 = {
                    valor: infoOpFunApl_valor$1,
                    inicio: -1,
                    final: -1,
                    numLinea: -1,
                    posInicioLinea: -1
                  };
                  return sigExprOperador(primeraExprId, infoOpFunApl$1, nivel$1, 14, /* Izq */0);
                } else {
                  return /* PExito */Block.__(0, [primeraExprId]);
                }
              }
          case /* TGenerico */2 :
              return /* PError */Block.__(1, ["Los genericos aun no estan soportados."]);
          case /* TNuevaLinea */0 :
          case /* TComentario */3 :
              continue ;
          case /* TNumero */4 :
              return /* PExito */Block.__(0, [/* ENumero */Block.__(2, [token[0]])]);
          case /* TTexto */5 :
              return /* PExito */Block.__(0, [/* ETexto */Block.__(3, [token[0]])]);
          case /* TBool */6 :
              return /* PExito */Block.__(0, [/* EBool */Block.__(4, [token[0]])]);
          case /* TOperador */7 :
              var textoErr = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["No se puede usar un operador como expresión. Si esa es tu intención, rodea el operador en paréntesis, por ejemplo: (+)\n\n" + (String(textoErr) + "")]);
          case /* TParenAb */8 :
              var infoParen = token[0];
              return sigExprParen(infoParen, obtNuevoNivel(infoParen));
          case /* TParenCer */9 :
              var textoErr$1 = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["No se esperaba un parentesis aquí. No hay ningún parentesis a cerrar.\n\n" + (String(textoErr$1) + "")]);
          case /* TAgrupAb */10 :
          case /* TAgrupCer */11 :
              return /* PError */Block.__(1, ["Otros signos de agrupación aun no estan soportados."]);
          case /* PC_SEA */12 :
              var nivel$2 = obtNuevoNivel(token[0]);
              try {
                var esMut = false;
                var token2 = Curry._1(lexer.sigToken, /* () */0);
                var preTokenId = token2;
                try {
                  Expect$KanComp._PC_MUT(token2, undefined, "");
                  esMut = true;
                  preTokenId = Curry._1(lexer.sigToken, /* () */0);
                }
                catch (exn){
                  
                }
                var infoTokenId = Expect$KanComp._TIdentificador(preTokenId, undefined, "Se esperaba un identificador");
                Expect$KanComp._TOperador(Curry._1(lexer.sigToken, /* () */0), "=", "Se esperaba el operador de asignaci\xc3\xb3n '=' luego del indentificador.");
                var match$2 = obtSigIndentacion(lexer, "Se esperaba una expresion luego del signo '='.", undefined, undefined);
                var nuevoNivel = match$2[0];
                if (match$2[1] && nuevoNivel <= nivel$2) {
                  throw [
                        Expect$KanComp.ErrorComun,
                        "La expresión actual está incompleta. Se esperaba una expresión indentada."
                      ];
                }
                var match$3 = sigExpresion(nuevoNivel, true, 0, /* Izq */0);
                if (typeof match$3 === "number") {
                  return /* PError */Block.__(1, ["Se esperaba una expresi\xc3\xb3n luego de la asignacion."]);
                } else if (match$3.tag) {
                  return /* PError */Block.__(1, ["Se esperaba una expresión luego de la asignación: " + (String(match$3[0]) + "")]);
                } else {
                  return /* PExito */Block.__(0, [/* EDeclaracion */Block.__(7, [{
                                  mut: esMut,
                                  id: {
                                    signatura: /* Indefinida */0,
                                    valor: infoTokenId
                                  },
                                  valor: match$3[0]
                                }])]);
                }
              }
              catch (raw_exn){
                var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn$1[0] === Expect$KanComp.ErrorComun) {
                  return /* PError */Block.__(1, [exn$1[1]]);
                } else {
                  throw exn$1;
                }
              }
          case /* PC_MUT */13 :
              var textoErr$2 = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["No se esperaba la palabra clave \'mut\' aquí.\n\n" + (String(textoErr$2) + "")]);
          
        }
      }
    };
  };
  var exprRe = sigExpresion(0, true, 0, /* Izq */0);
  if (typeof exprRe === "number") {
    return /* ExitoParser */Block.__(0, [/* EBloque */Block.__(8, [/* [] */0])]);
  } else if (exprRe.tag) {
    return /* ErrorParser */Block.__(1, [exprRe[0]]);
  } else {
    return /* ExitoParser */Block.__(0, [exprRe[0]]);
  }
}

exports.obtInfoFunAppl = obtInfoFunAppl;
exports.obtSigIndentacion = obtSigIndentacion;
exports.obtInfoOp = obtInfoOp;
exports.parseTokens = parseTokens;
/* No side effect */
