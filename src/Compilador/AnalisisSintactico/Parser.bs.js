// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Expect$KanComp = require("./Expect.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function obtPosExpr(_ex) {
  while(true) {
    var ex = _ex;
    switch (ex.tag | 0) {
      case /* EIdentificador */0 :
          var infoId = ex[0];
          return {
                  inicioPE: infoId.valorId.inicio,
                  numLineaPE: infoId.valorId.numLinea,
                  posInicioLineaPE: infoId.valorId.posInicioLinea
                };
      case /* EOperadorApl */6 :
          _ex = ex[0].izq;
          continue ;
      case /* EDeclaracion */7 :
          var eDec = ex[0];
          return {
                  inicioPE: eDec.inicioDec,
                  numLineaPE: eDec.numLineaDec,
                  posInicioLineaPE: eDec.posInicioLineaDec
                };
      case /* EBloque */8 :
          var exprs = ex[0];
          if (exprs) {
            _ex = exprs[0];
            continue ;
          } else {
            return {
                    inicioPE: 0,
                    numLineaPE: 0,
                    posInicioLineaPE: 0
                  };
          }
      default:
        var info = ex[0];
        return {
                inicioPE: info.inicio,
                numLineaPE: info.numLinea,
                posInicioLineaPE: info.posInicioLinea
              };
    }
  };
}

function $great$great$eq(a, f) {
  if (typeof a === "number" || a.tag) {
    return a;
  } else {
    return Curry._1(f, a[0]);
  }
}

function obtInfoFunAppl(esCurry, inicio, numLinea, posInicioLinea) {
  return {
          valor: esCurry ? "Ñ" : "ñ",
          inicio: inicio,
          final: inicio + 1 | 0,
          numLinea: numLinea,
          posInicioLinea: posInicioLinea
        };
}

function obtInfoOp(operador) {
  switch (operador) {
    case "&&" :
        return /* tuple */[
                6,
                /* Izq */0
              ];
    case "," :
        return /* tuple */[
                1,
                /* Izq */0
              ];
    case "+" :
    case "-" :
        return /* tuple */[
                10,
                /* Izq */0
              ];
    case "%" :
    case "*" :
    case "/" :
        return /* tuple */[
                11,
                /* Izq */0
              ];
    case "!=" :
    case "!==" :
    case "==" :
    case "===" :
        return /* tuple */[
                8,
                /* Izq */0
              ];
    case "<" :
    case "<=" :
    case ">" :
    case ">=" :
        return /* tuple */[
                9,
                /* Izq */0
              ];
    case "<<" :
    case ">>" :
        return /* tuple */[
                4,
                /* Izq */0
              ];
    case "." :
    case "?." :
        return /* tuple */[
                15,
                /* Izq */0
              ];
    case "??" :
        return /* tuple */[
                7,
                /* Izq */0
              ];
    case "^" :
        return /* tuple */[
                12,
                /* Der */1
              ];
    case "%=" :
    case "*=" :
    case "+=" :
    case "-=" :
    case "/=" :
    case "=" :
    case "^=" :
        return /* tuple */[
                2,
                /* Izq */0
              ];
    case "<|" :
    case "|>" :
        return /* tuple */[
                3,
                /* Izq */0
              ];
    case "||" :
        return /* tuple */[
                5,
                /* Izq */0
              ];
    default:
      if (operador === "Ñ" || operador === "ñ") {
        return /* tuple */[
                14,
                /* Izq */0
              ];
      } else {
        return /* tuple */[
                13,
                /* Izq */0
              ];
      }
  }
}

function parseTokens(lexer) {
  var parensAbiertos = {
    contents: 0
  };
  var generarTextoError = function (info) {
    var largo = info.final - info.posInicioLinea | 0;
    var substr = $$String.sub(lexer.entrada, info.posInicioLinea, largo);
    var espBlanco = $$String.make(info.inicio - info.posInicioLinea | 0, /* " " */32);
    var indicador = $$String.make(info.final - info.inicio | 0, /* "~" */126);
    var numLinea = info.numLinea;
    var strIndicadorNumLinea = " " + (String(numLinea) + " | ");
    var espacioBlancoIndicador = $$String.make(strIndicadorNumLinea.length, /* " " */32);
    var strIndicador = "" + (String(espBlanco) + ("" + (String(indicador) + "")));
    return "" + (String(strIndicadorNumLinea) + ("" + (String(substr) + ("\n" + (String(espacioBlancoIndicador) + ("" + (String(strIndicador) + "\n")))))));
  };
  var sigExprDeclaracion = function (nivel, esMut) {
    try {
      var infoTokenId = Expect$KanComp._TIdentificador(lexer.sigToken, undefined, "Se esperaba un identificador");
      Expect$KanComp._TOperador(lexer.sigToken, "=", "Se esperaba el operador de asignaci\xc3\xb3n '=' luego del indentificador.");
      var match = Curry._1(lexer.lookAheadSignificativo, false);
      var hayNuevaLinea = match[2];
      var nuevoNivel = match[1];
      if (hayNuevaLinea && nuevoNivel <= nivel) {
        throw [
              Expect$KanComp.ErrorComun,
              "La expresión actual está incompleta. Se esperaba una expresión indentada."
            ];
      }
      if (hayNuevaLinea) {
        Curry._1(match[3], /* () */0);
      }
      var match$1 = sigExpresion(nuevoNivel, nivel, true, 0, /* Izq */0, true);
      if (typeof match$1 === "number") {
        return /* PError */Block.__(1, ["Se esperaba una expresi\xc3\xb3n luego de la asignacion."]);
      } else {
        switch (match$1.tag | 0) {
          case /* PExito */0 :
              var exprDeclaracion = /* EDeclaracion */Block.__(7, [{
                    mut: esMut,
                    id: {
                      signatura: /* Indefinida */0,
                      valorId: infoTokenId
                    },
                    valorDec: match$1[0],
                    inicioDec: infoTokenId.inicio,
                    numLineaDec: infoTokenId.numLinea,
                    posInicioLineaDec: infoTokenId.posInicioLinea
                  }]);
              var exprRespuesta = /* PExito */Block.__(0, [exprDeclaracion]);
              var sigExpresionRaw = sigExpresion(nivel, nivel, true, 0, /* Izq */0, true);
              if (typeof sigExpresionRaw === "number") {
                return exprRespuesta;
              } else {
                switch (sigExpresionRaw.tag | 0) {
                  case /* PExito */0 :
                      var nuevaExpr = sigExpresionRaw[0];
                      if (nuevaExpr.tag === /* EBloque */8) {
                        return /* PExito */Block.__(0, [/* EBloque */Block.__(8, [/* :: */[
                                        exprDeclaracion,
                                        nuevaExpr[0]
                                      ]])]);
                      } else {
                        return /* PExito */Block.__(0, [/* EBloque */Block.__(8, [/* :: */[
                                        exprDeclaracion,
                                        /* :: */[
                                          nuevaExpr,
                                          /* [] */0
                                        ]
                                      ]])]);
                      }
                  case /* PError */1 :
                      return /* PError */Block.__(1, [sigExpresionRaw[0]]);
                  case /* PErrorLexer */2 :
                      return /* PErrorLexer */Block.__(2, [sigExpresionRaw[0]]);
                  
                }
              }
          case /* PError */1 :
              return /* PError */Block.__(1, ["Se esperaba una expresión luego de la asignación: " + (String(match$1[0]) + "")]);
          case /* PErrorLexer */2 :
              return /* PErrorLexer */Block.__(2, [match$1[0]]);
          
        }
      }
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Expect$KanComp.ErrorComun) {
        return /* PError */Block.__(1, [exn[1]]);
      } else {
        throw exn;
      }
    }
  };
  var sigExprOperador = function (exprIzq, infoOp, nivel, param, param$1, esExprPrincipal) {
    var valorOp = infoOp.valor;
    var match = obtInfoOp(valorOp);
    var asocOp1 = match[1];
    var precOp1 = match[0];
    var match$1 = sigExpresion(nivel, nivel, false, precOp1, asocOp1, false);
    if (typeof match$1 === "number") {
      match$1 === /* PEOF */0;
    } else {
      switch (match$1.tag | 0) {
        case /* PExito */0 :
            var eOperadorRes = {
              signaturaOp: /* Indefinida */0,
              valorOp: infoOp,
              precedencia: precOp1,
              asociatividad: asocOp1
            };
            var exprOpRes = /* EOperadorApl */Block.__(6, [{
                  op: eOperadorRes,
                  izq: exprIzq,
                  der: match$1[0]
                }]);
            var _lexerRes = Curry._1(lexer.sigToken, /* () */0);
            var _aceptarSoloOp = false;
            var _fnEnOp = function (param) {
              return /* () */0;
            };
            var _funValorDefecto = function (param) {
              return /* PReturn */1;
            };
            while(true) {
              var funValorDefecto = _funValorDefecto;
              var fnEnOp = _fnEnOp;
              var aceptarSoloOp = _aceptarSoloOp;
              var lexerRes = _lexerRes;
              if (typeof lexerRes === "number") {
                return /* PExito */Block.__(0, [exprOpRes]);
              } else if (lexerRes.tag) {
                return /* PError */Block.__(1, [lexerRes[0]]);
              } else {
                var token = lexerRes[0];
                switch (token.tag | 0) {
                  case /* TNuevaLinea */0 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        Curry._1(lexer.retroceder, /* () */0);
                        var match$2 = Curry._1(lexer.lookAheadSignificativo, true);
                        var fnEstablecer = match$2[3];
                        var indentacion = match$2[1];
                        var expresionRespuesta = /* PExito */Block.__(0, [exprOpRes]);
                        if (esExprPrincipal && indentacion >= nivel) {
                          if (indentacion === nivel) {
                            var nuevaFnEst = (function(fnEstablecer){
                            return function nuevaFnEst(param) {
                              Curry._1(fnEstablecer, /* () */0);
                              Curry._1(lexer.sigToken, /* () */0);
                              return /* () */0;
                            }
                            }(fnEstablecer));
                            var funSiNoEsOp = (function(fnEstablecer,expresionRespuesta){
                            return function funSiNoEsOp(param) {
                              Curry._1(fnEstablecer, /* () */0);
                              var sigExpresionRaw = sigExpresion(nivel, nivel, false, 0, /* Izq */0, true);
                              if (typeof sigExpresionRaw === "number") {
                                return expresionRespuesta;
                              } else {
                                switch (sigExpresionRaw.tag | 0) {
                                  case /* PExito */0 :
                                      var nuevaExpr = sigExpresionRaw[0];
                                      if (nuevaExpr.tag === /* EBloque */8) {
                                        return /* PExito */Block.__(0, [/* EBloque */Block.__(8, [/* :: */[
                                                        exprOpRes,
                                                        nuevaExpr[0]
                                                      ]])]);
                                      } else {
                                        return /* PExito */Block.__(0, [/* EBloque */Block.__(8, [/* :: */[
                                                        exprOpRes,
                                                        /* :: */[
                                                          nuevaExpr,
                                                          /* [] */0
                                                        ]
                                                      ]])]);
                                      }
                                  case /* PError */1 :
                                      return /* PError */Block.__(1, [sigExpresionRaw[0]]);
                                  case /* PErrorLexer */2 :
                                      return sigExpresionRaw;
                                  
                                }
                              }
                            }
                            }(fnEstablecer,expresionRespuesta));
                            _funValorDefecto = funSiNoEsOp;
                            _fnEnOp = nuevaFnEst;
                            _aceptarSoloOp = true;
                            _lexerRes = match$2[0];
                            continue ;
                          } else {
                            Curry._1(fnEstablecer, /* () */0);
                            _funValorDefecto = (function (param) {
                                return /* PReturn */1;
                              });
                            _fnEnOp = (function (param) {
                                return /* () */0;
                              });
                            _aceptarSoloOp = false;
                            _lexerRes = Curry._1(lexer.sigToken, /* () */0);
                            continue ;
                          }
                        } else {
                          return expresionRespuesta;
                        }
                      }
                  case /* TGenerico */2 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        var textoError = generarTextoError(token[0]);
                        return /* PError */Block.__(1, ["No se esperaba un genérico luego de la aplicación del operador.\n\n" + (String(textoError) + "")]);
                      }
                  case /* TComentario */3 :
                      _lexerRes = Curry._1(lexer.sigToken, /* () */0);
                      continue ;
                  case /* TOperador */7 :
                      var infoOp2 = token[0];
                      Curry._1(fnEnOp, /* () */0);
                      var match$3 = obtInfoOp(infoOp2.valor);
                      return sigExprOperador(exprOpRes, infoOp2, nivel, match$3[0], match$3[1], esExprPrincipal);
                  case /* TParenCer */9 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        Curry._1(lexer.retroceder, /* () */0);
                        return /* PExito */Block.__(0, [exprOpRes]);
                      }
                  case /* TAgrupAb */10 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        var textoError$1 = generarTextoError(token[0]);
                        return /* PError */Block.__(1, ["Este signo de agrupación aun no está soportado.\n\n" + (String(textoError$1) + "")]);
                      }
                  case /* TAgrupCer */11 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        var textoError$2 = generarTextoError(token[0]);
                        return /* PError */Block.__(1, ["Este signo de agrupación aun no está soportado.\n\n" + (String(textoError$2) + "")]);
                      }
                  case /* PC_LET */12 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        var textoError$3 = generarTextoError(token[0]);
                        return /* PError */Block.__(1, ["No se esperaba la palabra clave \'let\' luego de la aplicación del operador.\n\n" + (String(textoError$3) + "")]);
                      }
                  case /* PC_CONST */13 :
                      if (aceptarSoloOp) {
                        return Curry._1(funValorDefecto, /* () */0);
                      } else {
                        var textoError$4 = generarTextoError(token[0]);
                        return /* PError */Block.__(1, ["No se esperaba la palabra clave \'const\' luego de la aplicación del operador.\n\n" + (String(textoError$4) + "")]);
                      }
                  default:
                    if (aceptarSoloOp) {
                      return Curry._1(funValorDefecto, /* () */0);
                    } else {
                      var posEI = obtPosExpr(exprIzq);
                      var infoOp2$1 = obtInfoFunAppl(false, posEI.inicioPE, posEI.numLineaPE, posEI.posInicioLineaPE);
                      var match$4 = obtInfoOp(infoOp2$1.valor);
                      Curry._1(lexer.retroceder, /* () */0);
                      return sigExprOperador(exprOpRes, infoOp2$1, nivel, match$4[0], match$4[1], esExprPrincipal);
                    }
                }
              }
            };
        case /* PError */1 :
            return /* PError */Block.__(1, ["Se esperaba una expresion a la derecha del operador " + (String(valorOp) + (" :\n" + (String(match$1[0]) + ".")))]);
        case /* PErrorLexer */2 :
            return /* PErrorLexer */Block.__(2, [match$1[0]]);
        
      }
    }
    return /* PError */Block.__(1, ["Se esperaba una expresión a la derecha del operador " + (String(valorOp) + "")]);
  };
  var sigExprIdentificador = function (exprIdInfo, nivel, precedencia, param, esExprPrincipal) {
    var primeraExprId = exprIdInfo.expr;
    var infoIdInicio = exprIdInfo.infoInicio;
    var infoIdNumLinea = exprIdInfo.infoNumLinea;
    var infoIdPosInicioLinea = exprIdInfo.infoPosInicioLinea;
    var _lexerRes = Curry._1(lexer.sigToken, /* () */0);
    var _aceptarSoloOperador = false;
    var _fnEnOp = function (param) {
      return /* () */0;
    };
    var _funValorDefecto = function (param) {
      return /* PReturn */1;
    };
    while(true) {
      var funValorDefecto = _funValorDefecto;
      var fnEnOp = _fnEnOp;
      var aceptarSoloOperador = _aceptarSoloOperador;
      var lexerRes = _lexerRes;
      if (typeof lexerRes === "number") {
        return /* PExito */Block.__(0, [primeraExprId]);
      } else if (lexerRes.tag) {
        return /* PErrorLexer */Block.__(2, [lexerRes[0]]);
      } else {
        var token = lexerRes[0];
        switch (token.tag | 0) {
          case /* TNuevaLinea */0 :
              if (aceptarSoloOperador) {
                return Curry._1(funValorDefecto, /* () */0);
              } else {
                Curry._1(lexer.retroceder, /* () */0);
                var match = Curry._1(lexer.lookAheadSignificativo, true);
                var fnEstablecer = match[3];
                var indentacion = match[1];
                var expresionRespuesta = /* PExito */Block.__(0, [primeraExprId]);
                if (esExprPrincipal && indentacion >= nivel) {
                  if (indentacion === nivel) {
                    var nuevaFnEst = (function(fnEstablecer){
                    return function nuevaFnEst(param) {
                      Curry._1(fnEstablecer, /* () */0);
                      Curry._1(lexer.sigToken, /* () */0);
                      return /* () */0;
                    }
                    }(fnEstablecer));
                    var funSiNoEsOp = (function(fnEstablecer,expresionRespuesta){
                    return function funSiNoEsOp(param) {
                      Curry._1(fnEstablecer, /* () */0);
                      var sigExpresionRaw = sigExpresion(nivel, nivel, false, 0, /* Izq */0, true);
                      if (typeof sigExpresionRaw === "number") {
                        return expresionRespuesta;
                      } else {
                        switch (sigExpresionRaw.tag | 0) {
                          case /* PExito */0 :
                              var nuevaExpr = sigExpresionRaw[0];
                              if (nuevaExpr.tag === /* EBloque */8) {
                                return /* PExito */Block.__(0, [/* EBloque */Block.__(8, [/* :: */[
                                                primeraExprId,
                                                nuevaExpr[0]
                                              ]])]);
                              } else {
                                return /* PExito */Block.__(0, [/* EBloque */Block.__(8, [/* :: */[
                                                primeraExprId,
                                                /* :: */[
                                                  nuevaExpr,
                                                  /* [] */0
                                                ]
                                              ]])]);
                              }
                          case /* PError */1 :
                              return /* PError */Block.__(1, [sigExpresionRaw[0]]);
                          case /* PErrorLexer */2 :
                              return sigExpresionRaw;
                          
                        }
                      }
                    }
                    }(fnEstablecer,expresionRespuesta));
                    _funValorDefecto = funSiNoEsOp;
                    _fnEnOp = nuevaFnEst;
                    _aceptarSoloOperador = true;
                    _lexerRes = match[0];
                    continue ;
                  } else {
                    Curry._1(fnEstablecer, /* () */0);
                    _funValorDefecto = (function (param) {
                        return /* PReturn */1;
                      });
                    _fnEnOp = (function (param) {
                        return /* () */0;
                      });
                    _aceptarSoloOperador = false;
                    _lexerRes = Curry._1(lexer.sigToken, /* () */0);
                    continue ;
                  }
                } else {
                  return expresionRespuesta;
                }
              }
          case /* TGenerico */2 :
              if (aceptarSoloOperador) {
                return Curry._1(funValorDefecto, /* () */0);
              } else {
                var textoError = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["No se esperaba un genérico luego del identificador.\n\n" + (String(textoError) + "")]);
              }
          case /* TComentario */3 :
              console.log("Atorado en parser?");
              _lexerRes = Curry._1(lexer.sigToken, /* () */0);
              continue ;
          case /* TOperador */7 :
              var infoOp = token[0];
              Curry._1(fnEnOp, /* () */0);
              var match$1 = obtInfoOp(infoOp.valor);
              var asocOp = match$1[1];
              var precOp = match$1[0];
              if (precOp > precedencia || precOp === precedencia && asocOp === /* Der */1) {
                return sigExprOperador(primeraExprId, infoOp, nivel, precOp, asocOp, esExprPrincipal);
              } else {
                Curry._1(lexer.retroceder, /* () */0);
                return /* PExito */Block.__(0, [primeraExprId]);
              }
          case /* TParenCer */9 :
              if (aceptarSoloOperador) {
                return Curry._1(funValorDefecto, /* () */0);
              } else {
                Curry._1(lexer.retroceder, /* () */0);
                return /* PExito */Block.__(0, [primeraExprId]);
              }
          case /* TAgrupAb */10 :
              var textoError$1 = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["Este signo de agrupación aun no está soportado.\n\n" + (String(textoError$1) + "")]);
          case /* TAgrupCer */11 :
              var textoError$2 = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["Este signo de agrupación aun no está soportado.\n\n" + (String(textoError$2) + "")]);
          case /* PC_LET */12 :
              var textoError$3 = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["No se esperaba la palabra clave \'let\' luego de la aplicación del operador.\n\n" + (String(textoError$3) + "")]);
          case /* PC_CONST */13 :
              var textoError$4 = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["No se esperaba la palabra clave \'const\' luego de la aplicación del operador.\n\n" + (String(textoError$4) + "")]);
          default:
            if (aceptarSoloOperador) {
              return Curry._1(funValorDefecto, /* () */0);
            } else {
              Curry._1(lexer.retroceder, /* () */0);
              if (14 > precedencia) {
                var infoOpFunApl = obtInfoFunAppl(false, infoIdInicio, infoIdNumLinea, infoIdPosInicioLinea);
                return sigExprOperador(primeraExprId, infoOpFunApl, nivel, 14, /* Izq */0, esExprPrincipal);
              } else if (14 === precedencia && false) {
                var infoOpFunApl$1 = obtInfoFunAppl(false, infoIdInicio, infoIdNumLinea, infoIdPosInicioLinea);
                return sigExprOperador(primeraExprId, infoOpFunApl$1, nivel, 14, /* Izq */0, esExprPrincipal);
              } else {
                return /* PExito */Block.__(0, [primeraExprId]);
              }
            }
        }
      }
    };
  };
  var sigExpresion = function (nivel, _nivelPadre, iniciarIndentacionEnToken, precedencia, asociatividad, esExprPrincipal) {
    while(true) {
      var nivelPadre = _nivelPadre;
      var obtNuevoNivel = function (infoToken) {
        if (iniciarIndentacionEnToken) {
          return infoToken.inicio - infoToken.posInicioLinea | 0;
        } else {
          return nivel;
        }
      };
      var resultado = Curry._1(lexer.sigToken, /* () */0);
      if (typeof resultado === "number") {
        return /* PEOF */0;
      } else if (resultado.tag) {
        return /* PErrorLexer */Block.__(2, [resultado[0]]);
      } else {
        var token = resultado[0];
        switch (token.tag | 0) {
          case /* TNuevaLinea */0 :
              Curry._1(lexer.retroceder, /* () */0);
              var match = Curry._1(lexer.lookAheadSignificativo, true);
              if (match[1] >= nivel) {
                Curry._1(match[3], /* () */0);
                _nivelPadre = nivel;
                continue ;
              } else {
                return /* PReturn */1;
              }
          case /* TIdentificador */1 :
              var infoId = token[0];
              var exprIdInfo_expr = /* EIdentificador */Block.__(0, [{
                    signatura: /* Indefinida */0,
                    valorId: infoId
                  }]);
              var exprIdInfo_infoInicio = infoId.inicio;
              var exprIdInfo_infoNumLinea = infoId.numLinea;
              var exprIdInfo_infoPosInicioLinea = infoId.posInicioLinea;
              var exprIdInfo = {
                expr: exprIdInfo_expr,
                infoInicio: exprIdInfo_infoInicio,
                infoNumLinea: exprIdInfo_infoNumLinea,
                infoPosInicioLinea: exprIdInfo_infoPosInicioLinea
              };
              return sigExprIdentificador(exprIdInfo, obtNuevoNivel(infoId), precedencia, asociatividad, esExprPrincipal);
          case /* TGenerico */2 :
              return /* PError */Block.__(1, ["Los genericos aun no estan soportados."]);
          case /* TComentario */3 :
              _nivelPadre = nivel;
              continue ;
          case /* TNumero */4 :
              var infoNumero = token[0];
              var exprIdInfo_expr$1 = /* ENumero */Block.__(2, [infoNumero]);
              var exprIdInfo_infoInicio$1 = infoNumero.inicio;
              var exprIdInfo_infoNumLinea$1 = infoNumero.numLinea;
              var exprIdInfo_infoPosInicioLinea$1 = infoNumero.posInicioLinea;
              var exprIdInfo$1 = {
                expr: exprIdInfo_expr$1,
                infoInicio: exprIdInfo_infoInicio$1,
                infoNumLinea: exprIdInfo_infoNumLinea$1,
                infoPosInicioLinea: exprIdInfo_infoPosInicioLinea$1
              };
              return sigExprIdentificador(exprIdInfo$1, obtNuevoNivel(infoNumero), precedencia, asociatividad, esExprPrincipal);
          case /* TTexto */5 :
              var infoTexto = token[0];
              var exprIdInfo_expr$2 = /* ETexto */Block.__(3, [infoTexto]);
              var exprIdInfo_infoInicio$2 = infoTexto.inicio;
              var exprIdInfo_infoNumLinea$2 = infoTexto.numLinea;
              var exprIdInfo_infoPosInicioLinea$2 = infoTexto.posInicioLinea;
              var exprIdInfo$2 = {
                expr: exprIdInfo_expr$2,
                infoInicio: exprIdInfo_infoInicio$2,
                infoNumLinea: exprIdInfo_infoNumLinea$2,
                infoPosInicioLinea: exprIdInfo_infoPosInicioLinea$2
              };
              return sigExprIdentificador(exprIdInfo$2, obtNuevoNivel(infoTexto), precedencia, asociatividad, esExprPrincipal);
          case /* TBool */6 :
              var infoBool = token[0];
              var exprIdInfo_expr$3 = /* EBool */Block.__(4, [infoBool]);
              var exprIdInfo_infoInicio$3 = infoBool.inicio;
              var exprIdInfo_infoNumLinea$3 = infoBool.numLinea;
              var exprIdInfo_infoPosInicioLinea$3 = infoBool.posInicioLinea;
              var exprIdInfo$3 = {
                expr: exprIdInfo_expr$3,
                infoInicio: exprIdInfo_infoInicio$3,
                infoNumLinea: exprIdInfo_infoNumLinea$3,
                infoPosInicioLinea: exprIdInfo_infoPosInicioLinea$3
              };
              return sigExprIdentificador(exprIdInfo$3, obtNuevoNivel(infoBool), precedencia, asociatividad, esExprPrincipal);
          case /* TOperador */7 :
              var textoErr = generarTextoError(token[0]);
              return /* PError */Block.__(1, ["No se puede usar un operador como expresión. Si esa es tu intención, rodea el operador en paréntesis, por ejemplo: (+)\n\n" + (String(textoErr) + "")]);
          case /* TParenAb */8 :
              var infoParen = token[0];
              var infoParen$1 = infoParen;
              obtNuevoNivel(infoParen);
              parensAbiertos.contents = parensAbiertos.contents + 1 | 0;
              var sigToken = sigExpresion(0, 0, false, 0, /* Izq */0, true);
              if (typeof sigToken === "number") {
                if (sigToken === /* PEOF */0) {
                  var textoErr$1 = generarTextoError(infoParen$1);
                  var numLinea = infoParen$1.numLinea;
                  var numColumna = infoParen$1.inicio - infoParen$1.posInicioLinea | 0;
                  return /* PError */Block.__(1, ["El parentesis abierto en " + (String(numLinea) + ("," + (String(numColumna) + (" no está cerrado.\n\n" + (String(textoErr$1) + "")))))]);
                } else {
                  return /* PError */Block.__(1, ["Error de indentaci\xc3\xb3n. El parentesis no ha sido cerrado."]);
                }
              } else {
                switch (sigToken.tag | 0) {
                  case /* PExito */0 :
                      var ultimoToken = Curry._1(lexer.sigToken, /* () */0);
                      if (typeof ultimoToken === "number") {
                        var textoErr$2 = generarTextoError(infoParen$1);
                        var numLinea$1 = infoParen$1.numLinea;
                        var numColumna$1 = infoParen$1.inicio - infoParen$1.posInicioLinea | 0;
                        return /* PError */Block.__(1, ["El parentesis abierto en " + (String(numLinea$1) + ("," + (String(numColumna$1) + (" contiene una expresion, pero no está cerrado.\n\n" + (String(textoErr$2) + "")))))]);
                      } else if (ultimoToken.tag) {
                        var textoErr$3 = generarTextoError(infoParen$1);
                        var numLinea$2 = infoParen$1.numLinea;
                        var numColumna$2 = infoParen$1.inicio - infoParen$1.posInicioLinea | 0;
                        return /* PError */Block.__(1, ["El parentesis abierto en " + (String(numLinea$2) + ("," + (String(numColumna$2) + (" no está cerrado.\n\n" + (String(textoErr$3) + ("\nDebido a un error léxico: " + (String(ultimoToken[0]) + "")))))))]);
                      } else if (ultimoToken[0].tag === /* TParenCer */9) {
                        parensAbiertos.contents = parensAbiertos.contents - 1 | 0;
                        return /* PExito */Block.__(0, [sigToken[0]]);
                      } else {
                        return /* PError */Block.__(1, ["Se esperaba un cierre de parentesis."]);
                      }
                  case /* PError */1 :
                  case /* PErrorLexer */2 :
                      return sigToken;
                  
                }
              }
          case /* TParenCer */9 :
              if (parensAbiertos.contents > 0) {
                Curry._1(lexer.retroceder, /* () */0);
                return /* PReturn */1;
              } else {
                var textoErr$4 = generarTextoError(token[0]);
                return /* PError */Block.__(1, ["No se esperaba un parentesis aquí. No hay ningún parentesis a cerrar.\n\n" + (String(textoErr$4) + "")]);
              }
          case /* TAgrupAb */10 :
          case /* TAgrupCer */11 :
              return /* PError */Block.__(1, ["Otros signos de agrupación aun no estan soportados."]);
          case /* PC_LET */12 :
              return sigExprDeclaracion(obtNuevoNivel(token[0]), true);
          case /* PC_CONST */13 :
              return sigExprDeclaracion(obtNuevoNivel(token[0]), false);
          
        }
      }
    };
  };
  var exprRe = sigExpresion(0, 0, true, 0, /* Izq */0, true);
  if (typeof exprRe === "number") {
    return /* ExitoParser */Block.__(0, [/* EBloque */Block.__(8, [/* [] */0])]);
  } else {
    switch (exprRe.tag | 0) {
      case /* PExito */0 :
          return /* ExitoParser */Block.__(0, [exprRe[0]]);
      case /* PError */1 :
          return /* ErrorParser */Block.__(2, [exprRe[0]]);
      case /* PErrorLexer */2 :
          return /* ErrorLexerP */Block.__(1, [exprRe[0]]);
      
    }
  }
}

exports.obtPosExpr = obtPosExpr;
exports.$great$great$eq = $great$great$eq;
exports.obtInfoFunAppl = obtInfoFunAppl;
exports.obtInfoOp = obtInfoOp;
exports.parseTokens = parseTokens;
/* No side effect */
